<html>
	<head>
		<title>My first Three.js app</title>
		<style>
		body { margin:0; padding: 0; }
		/*canvas { width: 100%; height: 100% }*/
		</style>
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	</head>
	<body>
		<script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script>
		<script src="https://rawgithub.com/mrdoob/stats.js/master/build/stats.min.js"></script>
		<script>

		// set up the scene n stuff

		var scene = new THREE.Scene();
		scene.fog = new THREE.Fog( 0x143768, 1, 3 );
		// scene.fog = new THREE.Fog( 0x220022, 1, 3 );
		var camera = new THREE.PerspectiveCamera(
			70,
			window.innerWidth / window.innerHeight,
			0.1,
			1000);

		camera.position.z = 1.9;

		var renderer = new THREE.WebGLRenderer({antialias:true});
		var renderer = new THREE.CanvasRenderer({antialias:true});
		renderer.setClearColor(0x143768);
		renderer.setClearColor(0x000000);

		renderer.setSize(window.innerWidth, window.innerHeight);
		$('body').append(renderer.domElement);
		$(window).resize(function() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
			// controls.handleResize();
		});

		var play = false;

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		$('body').append(stats.domElement);

		var mouseX = mouseY = 0;

		$('canvas').click(function() {
			play = !play;
		}).on('mousemove', function(e) {
			mouseX = e.screenX;
			mouseY = e.screenY;
		});

		$(window).on('keyup', function(e) {
			if(e.keyCode == 82)
				reset();


		});

		var thetaX = (mouseY / window.innerHeight) * 2 * Math.PI;
		var thetaY = (mouseX / window.innerWidth) * 2 * Math.PI;


		var sign = function(x) { return x? x<0? -1 : 1 : 0; };

		// water drop class
		function WaterDrop() {


			this.size = 1;
			this.detail = 16;

			this.forceFactor = 0.008;
			this.normalDamping = 0.99;
			this.tangentDamping = 0.9;
			this.damping = 0.98;
			this.mergeThreshold = 0.8 * this.size / this.detail;
			this.iterations = 1;
			this.noiseFactor = 0.0;
			this.lvcFactor = -1.0;
			this.aspectRatio = 1.5;

			this.geometry = new THREE.BoxGeometry(
				this.size*this.aspectRatio,
				this.size,
				this.size,
				this.detail*this.aspectRatio,
				this.detail,
				this.detail);
			// this.geometry = new THREE.TorusGeometry(0.8, 0.2, 16, 50);
			// this.geometry = new THREE.IcosahedronGeometry(1,3);
			this.geometry.mergeVertices();


			var vertices = this.geometry.vertices;
			var faces = this.geometry.faces;
			var vertexCount = vertices.length;
			var i, count;

			this.material = new THREE.MeshBasicMaterial({color: 0x447733, wireframe: true });
			// this.material = new THREE.MeshBasicMaterial({color: 0x87c9ff, wireframe: true });
			// this.material = new THREE.MeshBasicMaterial({color: 0xff00ff, wireframe: true });
			this.mesh = new THREE.Mesh(this.geometry, this.material);

			this.addNoise = function(magnitude) {
				// introduce some noise
				for(i=0, count=vertices.length; i<count; i++) {

					// this.geometry.vertices[i].x *= 0.5;

					vertices[i].y += magnitude * (Math.random() - 0.5);
					vertices[i].x += magnitude * (Math.random() - 0.5);
					vertices[i].z += magnitude * (Math.random() - 0.5);
				}
			}

			this.neighborMap = null;
			this.vertexNormals = null;
			this.faceMap = null;

			this.velocity = new Array(vertices.length);
			var dv = this.velocity;

			for(i=0, count=vertices.length; i<count; i++)
				dv[i] = new THREE.Vector3(0,0,0);



			this.mcfMaterial = new THREE.LineBasicMaterial({color: 0x00ff00});
			this.mcfHelperGeom = new THREE.Geometry();
			this.mcfHelperObject = new THREE.Line(this.mcfHelperGeom, this.mcfMaterial);
			this.mcfHelperObject.type = THREE.LinePieces;

			this.velocityMaterial = new THREE.LineBasicMaterial({color: 0xff0000});
			this.velocityHelperGeom = new THREE.Geometry();
			this.velocityHelperObject = new THREE.Line(this.velocityHelperGeom, this.velocityMaterial);
			this.velocityHelperObject.type = THREE.LinePieces;

			this.mcfHelperGeom.vertices = new Array(vertices.length * 2);
			this.velocityHelperGeom.vertices = new Array(vertices.length * 2);
			for(i=0, count=vertices.length; i<count; i++) {
				this.mcfHelperGeom.vertices[i] = new THREE.Vector3(0,0,0);
				this.velocityHelperGeom.vertices[i] = new THREE.Vector3(0,0,0);
			}

			this.sortNeighbors = function(pairs) {
				if(pairs.length < 2)
					return [];

				var i, j, count = pairs.length/2, count2 = pairs.length;
				var neighbors = Array(count);

				neighbors[0] = pairs[0];
				neighbors[1] = pairs[1];

				var position = 1;

				// search for a pair containing the current vertex, and add its comrade to the end of the array
				for(i=0; i < count; i++) {
					// we can skip the first 2 since they've already been added
					for(j = 2; j < count2; j += 2) {
						if(pairs[j] === neighbors[position])
							neighbors[++position] = pairs[j +1 ];
						else if(pairs[j + 1] === neighbors[position])
							neighbors[++position] = pairs[j];
						else
							continue;
						pairs[j] = pairs[j + 1] = null;	// once a vertex is added, we don't want to find it again
						break;
					}
				}
				return neighbors;
			};

			// build a data structure mapping a vertex to an ordered array of the surrounding vertices
			this.buildNeighborMap = function() {
				var vertices = this.geometry.vertices;
				var faces = this.geometry.faces;
				var i, j, count, count2, face, neighbors;

				var neighborMap = Array(count);
				var vertexNormals = Array(count);

				for(i=0, count=vertices.length; i<count; i++)
					neighborMap[i] = new Array();

				// for each vertex, create a list of vertex pairs for each neighboring triangle
				for(i=0, count=faces.length; i<count; i++) {
					face = faces[i];
					if(face.a === face.b) {	// no degenerates!
						// console.log('skipping '+face.a +','+face.b+','+face.c);
						continue;
					}

					vertexNormals[face.a] = face.vertexNormals[0];
					vertexNormals[face.b] = face.vertexNormals[1];
					vertexNormals[face.c] = face.vertexNormals[2];

					neighbors = neighborMap[face.a];
					if(neighbors.indexOf(face.b) < 0)
						neighbors.push(face.b);
					if(neighbors.indexOf(face.c) < 0)
						neighbors.push(face.c);
					neighbors = neighborMap[face.b];
					if(neighbors.indexOf(face.a) < 0)
						neighbors.push(face.a);
					if(neighbors.indexOf(face.c) < 0)
						neighbors.push(face.c);
					neighbors = neighborMap[face.c];
					if(neighbors.indexOf(face.b) < 0)
						neighbors.push(face.b);
					if(neighbors.indexOf(face.a) < 0)
						neighbors.push(face.a);
				}
				this.neighborMap = neighborMap;
				this.vertexNormals = vertexNormals;
			};

			// nifty little algorithm that sums positive and negative volumes
			// of tetrahedrons from the origin to each face.
			// also calculates the center of mass of the mesh
			this.calculateVolume = function() {
				var face,
					volume,
					center,
					totalVolume = 0,
					centroid = new THREE.Vector3(0,0,0),
					A, B, C;

				for(i=0, count=faces.length; i<count; i++) {
					face = faces[i];
					A = vertices[face.a];
					B = vertices[face.b];
					C = vertices[face.c];

					// skip degenerate faces
					if(A === B || A === C || B === C)
						continue;

					volume = A.dot(B.clone().cross(C));
					totalVolume += volume;

					center = A.clone().add(B).add(C).multiplyScalar(volume / 4);
					centroid.add(center);
				}

				centroid.divideScalar(totalVolume);

				return totalVolume;
			};

			this.startingVolume = this.calculateVolume();

			// calculate the weighted sum of forces from each neighboring vertex
			// ...the "surface tension" if you will
			this.applySurfaceTension = function(i) {
				var vertices = this.geometry.vertices;
				var netForce = new THREE.Vector3(0,0,0);
				var neighbors, n, count, A = vertices[i], BA, f, totalLength = 0;

				neighbors = this.neighborMap[i];

				for(n=0, count=neighbors.length; n<count; n++) {
					BA = A.clone().sub(vertices[neighbors[n]]);
					totalLength += BA.length();

					netForce.sub(BA);
				}
				netForce.multiplyScalar(this.forceFactor * count/totalLength);
				this.velocity[i].add(netForce);

				netForce.multiplyScalar(this.lvcFactor / count);

				for(n=0, count=neighbors.length; n<count; n++)
					this.velocity[neighbors[n]].add(netForce);
					// this.velocity[neighbors[n]].add(this.vertexNormals[neighbors[n]]).setLength(volumeDelta.length());
			};


			this.applyVelocity = function(i) {
				// apply dV to vertex
				var v = this.velocity[i];

				this.geometry.vertices[i].add(v);
				v.multiplyScalar(this.damping);

				// if(this.vertexNormals[i] !== undefined) {
				// 	var vTangent = v.clone().projectOnPlane(this.vertexNormals[i]);
				// 	v.sub(vTangent);	// v is now just the normal component

				// 	v.multiplyScalar(this.normalDamping);
				// 	v.add(vTangent.multiplyScalar(this.tangentDamping));
				// }
			}

			// this.mcfHelperEnabled = true;


			this.frameCount = 0;

			this.evolve = function() {
				var vertices = this.geometry.vertices;
				var i, j, k, neighborCount, vertexCount = vertices.length;
				var A, B, v, f, f2, neighbors, neighborIndex;



				for(i=0; i<vertexCount; i++) {
					A = vertices[i];
					if(A.x == -1000)
						continue;

					// v = this.velocity[i];


					// if(this.mcfHelperEnabled) {
					// 	this.mcfHelperGeom.vertices[2 * i] = A.clone().multiplyScalar(0.01);
					// 	this.mcfHelperGeom.vertices[2 * i + 1] = v.clone().multiplyScalar(0.01);	// store initial velocity for later

						// this.velocityHelperGeom.vertices[2 * i] = A.clone();
						// this.velocityHelperGeom.vertices[2 * i + 1] = A.clone().add(v.clone().multiplyScalar(200));
					// }

					this.applySurfaceTension(i);

					this.applyVelocity(i);

				}

				var mergeTargets = [];
				var merged = [];
				var neighborCount;
				var BA;
				var vNormal;


				// console.debug("evolving!");
				// return;
				for(i=0; i<vertexCount; i++) {
					A = vertices[i];
					v = this.velocity[i];


					if(this.mcfHelperEnabled) {
						this.mcfHelperGeom.vertices[2 * i + 1] = this.mcfHelperGeom.vertices[2 * i + 1].sub(v);
					}

					// find the 2 faces faces sharing A and B (F1 and F2)
					// find the far vertices of F1 and F2 (C1, C2)
					// remove F1 and F2 from the faceMap of A, B, C1 and C2
					//

					// replace A with B in A's neighborMap and the faces in A's faceMap
					if(merged.indexOf(i) > -1)
						continue;

					neighbors = this.neighborMap[i];

					if(this.frameCount++ === 5) {
						this.frameCount = 0;

						// loop through the neighboring vertices to see if any of them are too close
						for(j=0, neighborCount=neighbors.length; j<neighborCount; j++) {
							neighborIndex = neighbors[j];



							// skip ones that have already been merged with another point
							if(merged.indexOf(neighborIndex) > -1)
								continue;

							B = vertices[neighborIndex];

							BA = A.clone().sub(B);

							if(BA.lengthManhattan() < this.mergeThreshold) {
								// we must now eliminate vertex A, and replace all references to it with B
								mergeTargets[i] = neighborIndex;
								merged.push(i);
								merged.push(neighborIndex);

								// average the velocities
								this.velocity[neighborIndex].add(v).multiplyScalar(0.5);
								v.a = v.b = v.c = 0;

								// move B half way to A
								B.add(BA.multiplyScalar(0.5));

								// this.replaceNeighbor(i, B);


								// break;
							}
						}
					}

					// if(this.mcfHelperEnabled) {
						// this.mcfHelperGeom.vertices[2 * i + 1] = this.mcfHelperGeom.vertices[2 * i + 1].multiplyScalar(-0.2).add(A);
					// }
				}

				// if(merged.length == 0)
				// 	return;

				var faces = this.geometry.faces;
				var vIndex, face, faceCount = faces.length;

				// search for vertex A in each face and replace it with B
				// starting at the end so we can delete things
				for(i=faceCount-1; i>=0; i--) {
					face = faces[i];

					if((vIndex = mergeTargets[face.a]) !== undefined)
						face.a = vIndex;
					if((vIndex = mergeTargets[face.b]) !== undefined)
						face.b = vIndex;
					if((vIndex = mergeTargets[face.c]) !== undefined)
						face.c = vIndex;

					// if this face is now degenerate, then erase it from this world
					if(face.a === face.b || face.a === face.c || face.b == face.c) {
						// console.log('removing degenerate face ' + i + '('+face.a+','+face.b+','+face.c+')');
						face.a = face.b = face.c = 0;
					}
				}

				var correctionFactor = Math.pow(this.startingVolume/this.calculateVolume(), 1/3);
				// if(this.frameCount == 2) {
				// 	console.log(volume);
				// 	console.log(correctionFactor);
				// }

				for(i=0; i<vertexCount; i++) {
					if(mergeTargets[i] === undefined) {
						vertices[i].x *= correctionFactor;
						vertices[i].y *= correctionFactor;
						vertices[i].z *= correctionFactor;
					} else {
						// console.log('removing vertex ' + i);
						vertices[i].x = -1000;
						vertices[i].y = -1000;
						vertices[i].z = -1000;
					}
				}


				this.geometry.elementsNeedUpdate = true;
				// this.geometry.buffersNeedUpdate = true;


				this.geometry.computeFaceNormals();
				this.geometry.computeVertexNormals();

				this.buildNeighborMap();



			};

		}





		var drop;

		function reset() {
			play = false;
			if(drop) {
				scene.remove(drop.mesh);
				scene.remove(drop.mcfHelperObject);
			}
			drop = new WaterDrop();

			drop.addNoise(drop.noiseFactor);
			drop.buildNeighborMap();

			scene.add(drop.mesh);

			if(drop.mcfHelperEnabled) {
				scene.add(drop.mcfHelperObject);
				// scene.add(drop.velocityHelperObject);
			}
		}
		reset();

		var frame = 0;
		var render = function() {

			frame++;
			if(play) {
				for(var i=0; i<drop.iterations; i++)
					drop.evolve();

				drop.geometry.verticesNeedUpdate = true;

				if(drop.mcfHelperEnabled) {
					drop.mcfHelperObject.geometry.verticesNeedUpdate = true;
					drop.velocityHelperObject.geometry.verticesNeedUpdate = true;
				}
			}
			// camera.fov = 10 + (mouseX / window.innerWidth) * 60;
			// camera.updateProjectionMatrix();

			mouseThetaX = (mouseY / window.innerHeight) * 2 * Math.PI;
			mouseThetaY = (mouseX / window.innerWidth) * 2 * Math.PI;

			if(frame == 1) {
				drop.mesh.rotation.x = mouseThetaX;
				drop.mesh.rotation.y = mouseThetaY;
				if(drop.mcfHelperEnabled) {
					drop.mcfHelperObject.rotation.x = mouseThetaX;
					drop.mcfHelperObject.rotation.y = mouseThetaY;

					drop.velocityHelperObject.rotation.x = mouseThetaX;
					drop.velocityHelperObject.rotation.y = mouseThetaY;
				}
			} else {
				dThetaX = (mouseThetaX - thetaX) / 16;
				dThetaY = (mouseThetaY - thetaY) / 16;
				thetaX += dThetaX;
				thetaY += dThetaY;
				drop.mesh.rotation.x = thetaX;
				drop.mesh.rotation.y = thetaY;

				if(drop.mcfHelperEnabled) {
					drop.mcfHelperObject.rotation.x = thetaX;
					drop.mcfHelperObject.rotation.y = thetaY;

					drop.velocityHelperObject.rotation.x = thetaX;
					drop.velocityHelperObject.rotation.y = thetaY;
				}
			}


			requestAnimationFrame(render);
			renderer.render(scene, camera);
			stats.update();
		}
		render();

		</script>
	</body>
</html>
